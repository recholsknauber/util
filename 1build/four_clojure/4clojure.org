* Basic Problems
** Recursive function
#+BEGIN_SRC clojure :results output
  (println (dec 5))
  (println ((fn foo [x] (when (> x 0) (conj (foo (dec x)) x))) 99))
#+END_SRC

#+RESULTS:
: 4
: (99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1)

** -> . Entity gets passed as the 2nd arg through functions left to right.
#+BEGIN_SRC clojure :results output
  ;; (= (#_blank (sort (rest (reverse [2 5 4 1 3 6]))))
  ;;    (-> [2 5 4 1 3 6] (reverse) (rest) (sort) (#_blank))
  ;;    5)
  (println (reverse [2 5 4 1 3 6]))
  (println (rest (reverse [2 5 4 1 3 6])))
  (println (sort (rest (reverse [2 5 4 1 3 6]))))

  (println (-> [2 5 4 1 3 6] (reverse) (rest) (sort)))
#+END_SRC

#+RESULTS:
: (6 3 1 4 5 2)
: (3 1 4 5 2)
: (1 2 3 4 5)
: (1 2 3 4 5)

** Loop and Recur. (Recur sends value back through loop.)
#+BEGIN_SRC clojure :results output
  (println
   (loop [x 5
	 result []]
    (if (> x 0)
      (recur (dec x) (conj result (+ 2 x)))
      result))
   )
#+END_SRC

#+RESULTS:
: [7 6 5 4 3]

** ->> . Entity gets passed as the last arg left to right.
#+BEGIN_SRC clojure :results output
  (println (->> [2 5 4 1 3 6] (drop 2)))
  (println  (->> [2 5 4 1 3 6] (drop 2) (take 3)))
  (println  (->> [2 5 4 1 3 6] (drop 2) (take 3) (map inc)))
  (println  (->> [2 5 4 1 3 6] (drop 2) (take 3) (map inc) (reduce +)))
#+END_SRC

#+RESULTS:
: (4 1 3 6)
: (4 1 3)
: (5 2 4)
: 11

** Anonymous function. Returns true iff the map contains an entry with that key and its value is nil.
#+BEGIN_SRC clojure :results output
  (defn isnil [x y] (if (and (= (x y) nil) (contains? y x)) true false))
  (println (true?  (isnil :a {:a nil :b 2})))
  (println (false? (isnil :b {:a nil :b 2})))
  (println (false? (isnil :c {:a nil :b 2})))
#+END_SRC

#+RESULTS:
: true
: true
: true

* Easy Problems
** For
#+BEGIN_SRC clojure
  (for [x (range 40)
	:when (= 1 (rem x 4))]
    x)

  (for [x (iterate #(+ 4 %) 0)
	:let [z (inc x)]
	:while (< z 40)]
    z)
#+END_SRC

#+RESULTS:
| 1 | 5 | 9 | 13 | 17 | 21 | 25 | 29 | 33 | 37 |

** Truth
#+BEGIN_SRC clojure
  (if-not false 1 0)
  (if [] 1 0)
  (if [0] 1 0)
#+END_SRC

#+RESULTS:
: 111

** Default values
#+BEGIN_SRC clojure
  (defn def-val-map
    [x y]
    (zipmap y (repeat x))
    )
  (def-val-map 2 #{:Ryan :Olivia :Robert})
#+END_SRC

#+RESULTS:
: #'four-clojure.core/def-val-map{:Olivia 2, :Robert 2, :Ryan 2}

** Some: returns the first logical true value.
#+BEGIN_SRC clojure :results output
  (println (some #{2 7 6} [5 6 7 8]))

  (println #(even? %) [5 6 7 8])
  (println #(when (even? %) %) [5 6 7 8])
  (println (some #(when (even? %) %) [5 6 7 8]))
#+END_SRC

#+RESULTS:
: 6
: #function[four-clojure.core/eval9313/fn--9314] [5 6 7 8]
: #function[four-clojure.core/eval9318/fn--9319] [5 6 7 8]
: 6

** Last element in a sequence (without using last).
#+BEGIN_SRC clojure :results output
  (defn my-last
    [x]
    (nth x (- (count x) 1)))

  (println (my-last [2 3 4 2 1]))
#+END_SRC

#+RESULTS:
: 1

** Return the nth element (without nth).
#+BEGIN_SRC clojure :results output
  (defn my-nth
    [x y]
    (last (take (+ y 1) x)))

  (my-nth '(4 5 6 7 8) 3)
#+END_SRC

** Count (without count).
#+BEGIN_SRC clojure :results output
  (defn count-seq
    [coll]
    (loop [x coll c 0]
      (let [nc
            (if (some? (first x))
              (+ c 1)
              c)]
        (do
          (println nc)
          (if (nil? (first x))
          nc
          (recur (rest x) nc))))))

  (count-seq '[1 2 3 "hello"])
#+END_SRC

** Reverse a sequence without reverse or rseq.
#+BEGIN_SRC clojure :results output
  (defn new-func [x]
    (keep x)
    (alitngkaihgia)
    )

  (println (new-func '("hello")))
#+END_SRC
